* Product Offer Aggregation
** Objective
Build an application that aggregates offers for a product.

An offer has two attributes:
- a floating point "price"
- a string "productCode".

A "product offer aggregation" has the following attributes:
- min price of the aggregated offers
- max price of the aggregated offers
- average price of the aggregated offers
- count of the offers

An aggregation can be in two states: ~open~ or ~closed~

Only aggregations with more than =N= offers can be closed, where =N= is
configurable and defaults to 3.

Sample data is [[file:data.csv][here]].

*** Acceptance criteria
- A closed aggregation does not accept any more offers.
- The service's API should allow:
  - querying for an aggregation for a given product code
  - closing the aggregation
  - supplying offers for the aggregation
- The offers to aggregate should be batched or streamed.

** Decisions
*** Remaining quota is not included in the OfferAppended event
Currently, there is no use case for an external entity to know about the state of the quota.
If there was a service reacting to that, we might include it in the future.

*** Aggregation state and summary of the product offers are decoupled
Other way is to couple status and order summary (e.g. `record State(status, statistics)`). That way, we could have
atomic operations through AtomicReference. It would work correctly. Two downsides are:
- more complex logic
- closing the aggregation would race with updating the statistics (probably not a big issue)

By decoupling them (i.e. updating status independently from statistics), we get a bit simpler implementation.
As previously, we expect races between closing and appending (i.e. something might get appended before we start and finish closing)