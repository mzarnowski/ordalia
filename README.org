* Product Offer Aggregation
** Dockerized application

To build the image, run
#+BEGIN_SRC bash
./gradlew build-docker-image
#+END_SRC

Image will be called product-offers:${VERSION} Rest endpoint listens on the port 8080 within the container.

*** Running the container locally
#+begin_src bash
docker container run \
      -e JAVA_OPTS="-Dproduct.offers.aggregation.quota=1" \
      -i -p 8080:8080 \
      --rm -t product-offers:<version>
#+end_src
*** Exposed endpoints:
**** Appending new offer
#+begin_src REST
POST http://localhost:8080/product/<product-code>/offers
Content-Type: application/json

<numerical-price>
#+end_src
**** Closing product aggregation
#+begin_src REST
PUT http://localhost:8080/product/<product-code>/offers/close
#+end_src
**** Requesting current aggregation
#+begin_src REST
GET http://localhost:8080/product/<product-code>/offers/aggregation
#+end_src
** Objective
Build an application that aggregates offers for a product.

An offer has two attributes:
- a floating point "price"
- a string "productCode".

A "product offer aggregation" has the following attributes:
- min price of the aggregated offers
- max price of the aggregated offers
- average price of the aggregated offers
- count of the offers

An aggregation can be in two states: ~open~ or ~closed~

Only aggregations with more than =N= offers can be closed, where =N= is
configurable and defaults to 3.

Sample data is [[file:data.csv][here]].

*** Acceptance criteria
- A closed aggregation does not accept any more offers.
- The service's API should allow:
  - querying for an aggregation for a given product code
  - closing the aggregation
  - supplying offers for the aggregation
- The offers to aggregate should be batched or streamed.

** Decisions
*** Remaining quota is not included in the OfferAppended event
Currently, there is no use case for an external entity to know about the state of the quota.
If there was a service reacting to that, we might include it in the future.

*** Aggregation state and summary of the product offers are decoupled
Other way is to couple status and order summary (e.g. `record State(status, statistics)`). That way, we could have
atomic operations through AtomicReference. It would work correctly. Two downsides are:
- more complex logic
- closing the aggregation would race with updating the statistics (probably not a big issue)

By decoupling them (i.e. updating status independently from statistics), we get a bit simpler implementation.
As previously, we expect races between closing and appending (i.e. something might get appended before we start and finish closing)
