* Product Offer Aggregation
** Objective
Build an application that aggregates offers for a product.

An offer has two attributes:
- a floating point "price"
- a string "productCode".

A "product offer aggregation" has the following attributes:
- min price of the aggregated offers
- max price of the aggregated offers
- average price of the aggregated offers
- count of the offers

An aggregation can be in two states: ~open~ or ~closed~

Only aggregations with more than =N= offers can be closed, where =N= is
configurable and defaults to 3.

Sample data is [[file:data.csv][here]].

*** Acceptance criteria
- A closed aggregation does not accept any more offers.
- The service's API should allow:
  - querying for an aggregation for a given product code
  - closing the aggregation
  - supplying offers for the aggregation
- The offers to aggregate should be batched or streamed.

** Decisions
*** Return events through the API
Given an API which allows to "close" the aggregation, we want to let the user know if the operation was successful.
There are multiple causes for it to not affect the aggregation, the most basic being: it is already closed.

In this case, we could return a boolean, but this doesn't allow us to distinguishing between interacting with an
already closed aggregation. By returning a list of "events", which resulted from the operation, we have an easy interface
to expose various reasons something happened (or not). Additionally, returning an empty list means "nothing happened".

*** Remaining quota is not included in the OfferAppended event
Currently, there is no use case for an external entity to know about the state of the quota.
If there was a service reacting to that, we might include it in the future.

*** Aggregation state and summary of the product offers are decoupled
Other way is to couple status and order summary (e.g. `record State(status, statistics)`). That way, we could have
atomic operations through AtomicReference. It would work correctly. Two downsides are:
- more complex logic
- closing the aggregation would race with updating the statistics (probably not a big issue)

By decoupling them (i.e. updating status independently from statistics), we get a bit simpler implementation.
As previously, we expect races between closing and appending (i.e. something might get appended before we start and finish closing)